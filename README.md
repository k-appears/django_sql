### Architecture Overview

The Django app created above follows a typical architecture for building RESTful APIs using Django and Django REST
Framework (DRF) using Swagger API to visualize the API. Here's an overview of the architecture:

1. **Models**: The `app.models` module contains Django model classes that define the structure of the application's
   data. In this app, we have the models `Simulation` and `Machine`, the queries are done without using Django ORM but
   with plain SQL mapped to the Models.
   The reasons are the following:
    1. Portability: SQL queries can be easily ported to other database systems without significant changes.
    2. Built-in Security Features: Django's ORM Models provides built-in protection against common security
       vulnerabilities
       like SQL injection attacks.
    3. Mantenability in Schema Changes: Using the Django migrations system to manage schema changes but manually
       creating tables, constraints and relations with bare DDL.

2. **Serializers**: The `app.serializers` module contains DRF serializer classes that define how data is serialized and
   deserialized between Python objects and JSON representations.

3. **Views**: The `app.views` module contains Django view classes that handle incoming HTTP requests and return HTTP
   responses. These views are responsible for processing data, interacting with models and serializers, and returning
   appropriate responses to clients.

4. **URLs**: The `app.urls` module contains URL patterns that map incoming HTTP requests to specific views. Using RESTful
   Framework's `routers` to automatically generate URL patterns for the views to manage resources.

5. **Tests**: The `tests` directory contains unit tests and integration tests.

6. **Settings**: The `settings.py` file contains configuration settings for the Django app, such as database settings,
   middleware configurations, and installed apps.

7. **Migrations**: The `migrations` directory contains database migration files generated by Django's migration system.
   These migration files represent changes to the database schema over time and allow for easy database schema updates.

Overall, this architecture follows the Model-View-Controller (MVC) pattern, with Django handling the Model and
Controller aspects, DRF facilitating the creation of RESTful APIs and Swagger API the interaction with the end user.

### Asumptions

* In description mentions: `You should use bare SQL to exploit your application's data`
  I assume `exploit` means to **use** data, modify can be done with ORM.
* Default Ordering is ascending.
* API Client or Swagger user can select either order or filtering but not both at the same time.

### Run in Docker

#### Requirements

1. install `docker`

#### Steps

``` bash
docker build -t django-manuel-ch .
docker run -p 8000:8000 django-manuel-ch
```

Finally, open http://localhost:8000/ to open Swagger API.

### Run manually

#### Requirements

1. install `pyenv`

#### Steps

``` bash
pyenv install 3.12.0
$(pyenv which python3.12) -m venv .venv
chmod +x .venv/bin/activate
.venv/bin/activate
pip install poetry
poetry install
poetry run python manage.py migrations
poetry run python manage.py runserver
```

Finally, open http://localhost:8000/
